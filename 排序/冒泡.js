//  4，5，6，3，2，1
// 冒泡拍序：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进⾏⽐较，看是否满⾜⼤⼩关系要求。如果不 满⾜就让它俩互换。⼀次冒泡会让⾄少⼀个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序⼯作

function bubbleSort(arr) {
  console.log(arr.length)
  if(arr.length === 1) return arr
  else {
    for(let i=0; i<arr.length; i++) {
      // flag用于记录当前如果没有变化，就说明有序了 就终止
      let flag = false;
      for(let j=arr.length-1;j>i; j--) {
        if(arr[j] < arr[j-1]) {
          [arr[j], arr[j-1]] = [arr[j-1], arr[j]]
          flag = true
        }
      }
      if(flag = false) break;
    }
    console.log(arr)
    return arr;
  }
}

bubbleSort([4,5,6,3,2,1])

/**
 * 1. 冒泡排序是原地排序算法吗？
 * 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是⼀个原地排序算法。
 * 2. 冒泡排序是稳定的排序算法吗？
 * 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素⼤⼩ 相等的时候，我们不做交换，相同⼤⼩的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
 * 3. 时间复杂度
 * 最好情况下，要排序的数据已经是有序的了，我们只需要进⾏⼀次冒泡操作，就可以结束了，所以最好情况时间复杂度 是O(n)。⽽最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进⾏n次冒泡操作，所以最坏情况时间复杂度为 O(n2)。
 */